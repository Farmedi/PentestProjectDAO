// SPDX-License-Identifier: FT
pragma solidity ^0.8.0;

import "./Utils/StringUtils.sol";
import "./Interfaces/TaskAssignmentInterface.sol";

contract Project is TaskAssignmentInterface{
    uint256 public deadlineUnitEpoc;        //Test süresi
    uint256 public budgetUnitEthereum;      //Test bütçesi
    string public projectName;              //Test yapılacak kurumun adı

    string[] private tasks;                         //Yöneticinin oluşturduğu task'ların listesi

    TaskAssignment[]  taskAssignments;

    constructor (uint256 budget, uint256 deadline, string memory name) {    
        deadlineUnitEpoc = deadline;
        budgetUnitEthereum = budget;
        projectName = name;
    }

    function createTasks(string memory taskName) public {
        /*PY bu metodu kullanarak task oluşturabilir.*/
        
        (bool alreadyExists) = StringUtilities.findString(tasks, taskName);
        if (alreadyExists) {
            return;
        }
        tasks.push(taskName);
    }

    function assignTasks(string memory taskName, address _assignee) public {
        /*PY daha önce oluşturduğu task'ları bu metod ile çalışanlara atayabilir. */

        require(StringUtilities.findString(tasks, taskName), "Task doesn't exist.");
        require(checkIfTaskAlreadyAssigned(taskName), "Task is already assigned to someone");

        pushToTaskMappings(taskName,_assignee);
    }


    function listAssignedTasksOfAssignee(address _assignee) public view returns (string[] memory) {
        /*Çalışanın üzerinde bulunan task'ları görüntüler.*/
        string[] memory taskNames = new string[](tasks.length);
        uint counter = 0;
        for (uint i = 0; i < taskAssignments.length; i++) {
            if (taskAssignments[i].assignee == _assignee) {
                taskNames[counter]=taskAssignments[i].task;
                counter++;
            }
        }
        return taskNames;
    }

    function checkIfTaskAlreadyAssigned(string memory _taskName) internal view returns (bool){
        /*Ataması yapılmaya çalışılan task'ın halihazırda atanmış olup olmadığı sonucunu döndürür.*/
        for (uint256 i = 0; i < taskAssignments.length; i++) {
            if(StringUtilities.compareStrings(taskAssignments[i].task, _taskName)){
                return false;
            }
        }
        return true;
    }

    function pushToTaskMappings(string memory _task, address _assignee ) internal  {
        /*Task ataması yapıldıktan sonra çağrılan bu fonksiyon taskMapping mapping'ini günceller.*/
        
        TaskAssignment memory newAssignment = TaskAssignment({
            task: _task,
            assignee: _assignee
        });
        taskAssignments.push(newAssignment);
        
    }

    function viewAllAssignments() public view returns(TaskAssignment[] memory){
        /*Mevcut task atamalarını gösterir.*/
        return taskAssignments;
    }

    function viewAllTasks() public view returns (string[] memory){
        /*Mevcut task'ları gösterir.*/
        return tasks;
    }



}
