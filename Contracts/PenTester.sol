// SPDX-License-Identifier: FT
pragma solidity ^0.8.0;

import "./Interfaces/TaskAssignmentInterface.sol";
import "./Project.sol";
import "./ProjectManager.sol";
import "./Utils/StringUtils.sol";

contract PenTester {

    address managersAddress;
    string[] projectsCurrentlyParticipatingIn;

    mapping(string => string[]) public tasksOnProjectMapping;
    mapping(string => mapping(string => string[])) vulnerabilityMapping;

    struct workload {
        string projectName;
        string[] tasks;
    }

    constructor(address _managersAddress){
        managersAddress = _managersAddress;
    }

    function generateWorkloads() public {
     Project[] memory activeProjects = ProjectManager(managersAddress).viewProjectsOnProjectManager();
     require(activeProjects.length>0,"No active projects running at the moment.");

        for(uint i = 0; i < activeProjects.length; i++){
            Project  tempProject = Project(activeProjects[i]);
            string memory tempProjectName = tempProject.projectName();
            tasksOnProjectMapping[tempProjectName]=tempProject.listAssignedTasksOfAssignee(msg.sender);
            if (!StringUtilities.findString(projectsCurrentlyParticipatingIn,tempProjectName)){
            projectsCurrentlyParticipatingIn.push(tempProject.projectName());
            }
            
        }

    }

    function getTasksOnProject(Project project) internal view returns(string[] memory){
        return project.listAssignedTasksOfAssignee(msg.sender);
    }

    function viewCurrentWorkloads() public view returns(workload[] memory){
        workload[] memory currentWorkload = new workload[](projectsCurrentlyParticipatingIn.length);
        for(uint i = 0; i<projectsCurrentlyParticipatingIn.length;i++){
            string memory iteratedProjectName = projectsCurrentlyParticipatingIn[i];
            currentWorkload[i]=workload({
                projectName: iteratedProjectName,
                tasks: tasksOnProjectMapping[iteratedProjectName]
            });
        
        
        }

        return currentWorkload;
    }

    function inputVulnerabilityForTask() public view {
        
    }

}